Hookup ("Монтажная схема") - лаконичная структура, описывающая
ввод и (частично) вывод юнита. На её основе происходит:

* Валидация данных.
* Генерация основы для графического интерфейса.
* Сопряжение юнитов в цепочке.

Монтажная схема гарантирует, что на входе юнита всегда
будут данные, которые возможно корректно обработать.

### Пример монтажной схемы

	input =>
		name1 =>
			elem => definition1
			norm => value1
		name2 =>
			elem => definition2
			norm => value2
			dimension => 3
		name3 =>
			map =>
				name3.1 =>
					name3.1.1 =>
						elem => definition3
						norm => value3
					name3.1.2 =>
						elem => definition4
						norm => value4
						dimension => 1
				name3.2 =>
					elem => definition5
					norm => value5
					dimension => 2
	    name4 => false
	mode =>
	    mode1 =>
		    - name1
		    - name2
		    - name3
	    mode2 =>
		    - name3
		    - name4

Каждый параметр **условно** имеет тип:

* Не структура(no-struct) — неструктурированная переменная, но может иметь размерность.
* Структура(struct) — структурированная переменная.
Признаком структуры является наличие параметра map.
Примером структуры может служить сам hookup.

Каждый параметр (или внутренний элемент параметра в случае структуры),
ОБЯЗАН иметь описание допустимых значений (**elem**) в виде шаблона для регулярного выражения.
В случае несоответствия кидается исключение `checkingError`
Для булевых переменных допустим краткий синтаксис: name => false

Каждый параметр (или внутренний элемент параметра, в случае структуры),
МОЖЕТ иметь стандартное значение (**norm**). Если при использовании юнита входной параметр не передается, используется стандартное значение, если и оно не задано - кидается исключение `missError`

Также каждый параметр МОЖЕТ иметь размерность (**dimension**) со значением в диапозоне [1:3],
т.е. допускаются только 1/2/3-мерные массивы. Это ограничение не несет какого либо
технического смысла, а является лишь разумным "ограничением на сложность" - наврятли
кому-то понадобятся структуры, которые даже сложно вообразить.
При несоответствии размерности кидается исключение
`dimensionError`. **Важно**: ключи могут быть как строковые, так и числовые.

Помимо описания ввода, можно указать наличие нескольких режимов, с перечислением своего
набора параметров для каждого.

**Важно**: Схема лишь регламентирует количество и структуру параметров, независимую от самого понятия "тип данных".
Проверка на допустимые значения не является проверкой на тип данных (типизация динамическая).


### Почему именно так?

Касательно регулярных выражений - на данный момент любой параметр юнита есть текст и ничего
более удобного и одновременно универсального для проверки сигнатур текста ещё не придумано.
Дыаа, регулярки медленные, дыаа, их не все знают, но ничего лучше просто нет.

Цель монтажной схемы состоит в минимальном описании заранее неизвестных входных данных,
что должно способствовать достижению требуемой гибкости юнитов. Например, тут нет ограничения
на количество элементов в последовательностях: если параметр объявлен как последовательность,
в нём может быть как 0, так и 100500 элементов. Нет типов данных - на уровне использования
юнита это лишняя информация.

**MAYBE**: в последующих версиях параметром юнита может быть ссылка на дескриптор (файла, сокета, потока ввода/вывода и пр.). В этом случае для параметров вместо регулярок имеет смысл
проверять какие-то бинарные сигнатуры, вроде размера, наличия нулбайтов etc.
