Вначале ставиться shabang: #!/usr/bin/env bash
Сделать скрипт исполняемым:
    
    chmod +rx scriptname  # выдача прав на чтение/исполнение любому пользователю
    chmod u+rx scriptname # выдача прав на чтение/исполнение только "владельцу" скрипта


### Ввод-вывод

    echo	выводит выражение или содержимое переменной (на stdout)
    printf	команда форматированного вывода, расширенный вариант команды echo
    read	«читает» значение переменной со стандартного ввода (stdin), в интерактивном режиме это клавиатура

### Файловая система

    cd	изменяет текущий каталог
    pwd	выводит название текущего рабочего каталога (от англ. print working directory)

### Действия над переменными

    let	производит арифметические операции над переменными
    eval	транслирует список аргументов из списка в команды
    set	изменяет значения внутренних переменных скрипта
    unset	удаляет переменную (фактически устанавливает её значение в null)
    export	экспортирует переменную, делая её доступной дочерним процессам
    declare, typeset	задают и/или накладывают ограничения на переменные
    getopts	используется для разбора аргументов, передаваемых скрипту из командной строки

### Управление сценарием

    source, . (точка)	запуск указанного сценария
    exit	безусловное завершение работы сценария
    exec	заменяет текущий процесс новым, запускаемым командой exec
    shopt	позволяет изменять ключи (опции) оболочки на лету

### Команды

    true	возвращает код завершения ноль (успешное завершение)
    false	возвращает код завершения, который свидетельствует о неудаче
    type prog	выводит полный путь к prog
    hash prog	запоминает путь к prog
    help COMMAND	выводит краткую справку по использованию внутренней команды COMMAND

### Потоки

Стандартные потоки ввода вывода(дескрипторы): 0 (stdin), 1 (stdout), 2 (stderr).
Для операций с этими дескрипторами, существуют специальные символы:
> (перенаправление вывода)
< (перенаправление ввода).
Символ & предваряет номер дескриптора; например, 2>&1 — перенаправление
дескриптора 2 (stderr) в дескриптор 1 (stdout).

Пример одновременного перенаправления стандартного вывода и стандартных ошибок:

    command &> file
    

### Разное

Проверка существования команды в системе:

hash NAME_COMMAND 2>/dev/null ||
{ echo >&2 "I require foo but it's not installed.  Aborting."; exit 1; }


# make Filedescriptor(FD) 6 a copy of stdout (FD 1)
exec 6>&1
# open file "test.data" for writing
exec 1>test.data
# produce some content
echo "data:data:data"
# close file "test.data"
exec 1>&-
# make stdout a copy of FD 6 (reset stdout)
exec 1>&6
# close FD6
exec 6>&-

# open file test.data for reading
exec 6<test.data
# read until end of file
while read -u 6 dta
do
  echo "$dta" 
done
# close file test.data
exec 6<&-

# выполнить 'date' и поместить результат в VAR
VAR=$(date)
echo "$VAR" выведет дату на момент вызова предыдущей строки

# Условие
if [[ $T1 == "$T2" ]]; then
  echo 'условие выполняется'
else
  echo 'условие не выполняется'
fi


for i in {1..10};
do
  echo "$i"
done

COUNTER=0
while [[ $COUNTER -lt 10 ]]; do
  echo The counter is $COUNTER
  let COUNTER=COUNTER+1
done

i=0
until [[ $i -eq 10 ]]
do
  echo "$i"
  i=$[$i+1]
done

#~ внутри двойных круглых скобок переменные можно писать в Си-стиле (без $ и разделяя пробелом операторы и операнды)
for (( i = 0; i < 10; i++ )); do
	echo -n "$i; "
done

### Массивы

В BASH реализованы только одномерные hash массивы.

Получить строку, состоящую из всех элементов массива, разделённых пробелом.

values=${arr[@]}
Получить строку со всеми индексами массива, независимо от того, численные они или цифровые:

keys=${!arr[@]}
Осуществить массовую замену первого вхождения подстроки "MAY" на "MARCH" во всех элементах массива и вернуть строку, составленную из результирующих элементов массива, разделённых пробелом:

values=${arr[@]/MAY/MARCH}
То же самое, но в каждом элементе массива будут заменены все вхождения подстроки "MAY":

values=${arr[@]//MAY/MARCH}

Array=(element1 element2 element3)

Добавление элементов в конец индексированного массива:

declare -a arrAnimals
arrAnimals=(dog elephant horse cow)
# Выводим содержимое массива:
echo "${arrAnimals[@]}"
# В конец массива arrAnimals добавляем новый элемент: "pig"
arrAnimals+=(pig)
# И снова показываем содержимое массива:
echo "${arrAnimals[@]}"
Получить первый элемент массива:

echo "${arrAnimals[0]}"
# or:
echo "${arrAnimals[@]:0:1}"
Получить последний элемент массива:

echo "${arrAnimals[@]:${#arrAnimals[@]}-1}"


С помощью ассоциативных массивов можно имитировать поддержку многомерных массивов:

declare -A a         # объявляет ассоциативный массив 'a'
i=1; j=2             # инициализация нескольких индексов
a[$i,$j]=5           # присвоение значения "5" в ячейку "$i,$j" (т.е. "1,2")
echo ${a[$i,$j]}     # вывод хранимых значений из "$i,$j"

Конвеер: cat filename | grep something

Математика

VAR=55             # Устанавливаем переменную VAR, равной 55
((VAR = VAR + 1))  # Добавляем единицу к переменной VAR. Обратите внимание на отсутствие знака '$' 
((VAR+=1))         # Сокращённая форма записи инкремента
((++VAR))          # Другой способ увеличения VAR на единицу. Выполняет префиксный инкремент
((VAR++))          # Другой способ увеличения VAR на единицу. Выполняет постфиксный инкремент
echo $[VAR * 22]   # Умножаем VAR на 22 и передаем результат команде
echo $((VAR * 22)) # Другой способ сделать то же
((VAR<<3))         # Побитовый сдвиг влево (то же, что VAR*8)
((VAR>>3))         # Побитовый сдвиг вправо (то же, что VAR/8)

Логика

|| логическая операция OR (логическое ИЛИ). В операциях проверки условий,
оператор || возвращает 0 (success), если один из операндов имеет значение true (ИСТИНА).

&& логическая операция AND (логическое И). В операциях проверки условий,оператор && возвращает
0 (success) тогда, и только тогда, когда оба операнда имеют значение true (ИСТИНА).


### Аргументы


    $$	pid текущего shell (самого процесса-сценария)
    $!	pid последнего процесса в фоновом режиме
    $?	код возврата последнего процесса (функции или скрипта)
    $x	где x — номер параметра, переданного скрипту ($1, $2 и т. д., $0 — последний запущенный скрипт)
    $#	количество аргументов командной строки
    $*	все аргументы в виде одной строки (слова)
    $@	то же самое, что и $*, но при этом каждый параметр представлен как отдельная строка (слово)
    $-	список флагов, переданных сценарию
    $_	содержит последний аргумент предыдущей команды

### Встроенные переменные

    $BASH	путь к исполняемому файлу bash
    $BASH_VERSINFO[n]	массив, состоящий из 6 элементов, содержащий информацию о версии bash
    $BASH_VERSION	версия Bash, установленного в системе
    $DIRSTACK	содержимое вершины стека каталогов
    $EDITOR	заданный по умолчанию редактор
    $EUID	«эффективный» идентификационный номер пользователя (Effective User ID)
    $FUNCNAME	имя текущей функции
    $GLOBIGNORE	перечень шаблонных символов, которые будут проигнорированы при выполнении подстановки имен файлов (globbing)
    $GROUPS	группы, к которым принадлежит текущий пользователь
    $HOME	домашний каталог пользователя
    $HOSTNAME	сетевое имя хоста
    $HOSTTYPE	тип машины (идентифицирует аппаратную архитектуру)
    $IFS	разделитель полей во вводимой строке
    $LC_COLLATE	задает порядок сортировки символов, в операциях подстановки имен файлов и в поиске по шаблону
    $LC_CTYPE	определяет кодировку символов
    $LINENO	Номер строки исполняемого сценария
    $MACHTYPE	аппаратная архитектура
    $OLDPWD	прежний рабочий каталог
    $OSTYPE	тип операционной системы
    $PATH	путь поиска (включает в себя каталоги /usr/bin/, /usr/X11R6/bin/, /usr/local/bin и т. д.)
    $PIPESTATUS	Код возврата канала (конвейера)
    $PPID	PID (идентификатор) родительского процесса
    $PS1	приглашение командной строки
    $PS2	вторичное приглашение командной строки, выводится тогда, когда от пользователя ожидается дополнительный ввод. Отображается как «>»
    $PS3	третичное приглашение, выводится, когда пользователь должен сделать выбор в операторе select
    $PS4	приглашение четвёртого уровня, выводится в начале каждой строки вывода тогда, когда сценарий вызывается с ключом -x. Отображается как «+»
    $PWD	рабочий (текущий) каталог
    $REPLY	переменная по умолчанию, куда записывается ввод пользователя, выполненный с помощью команды read
    $SECONDS	время работы сценария (в секундах)
    $SHELLOPTS	список допустимых опций интерпретатора (доступна только для чтения)
    $SHLVL	уровень вложенности shell
    
### Регулярки

Синтаксис регулярных выражений задокументирован на страницах документации man 7 regex.

    REGEXP='foo(bar)bl(.*)'
    if  [[ "abcfoobarbletch" =~ $REGEXP ]]
    then
      echo "Регулярное выражение совпало со строкой!" 
      echo "$BASH_REMATCH"       # выводит: foobarbletch 
      echo "${BASH_REMATCH[1]}" # выводит: bar 
      echo "${BASH_REMATCH[2]}" # выводит: etch 
    fi
    
### Lifecicle

Bash при запуске вызывает команды из множества различных скриптов.

Когда Bash вызывается как интерактивная оболочка входа в систему, первым делом он читает
и вызывает команды из файла /etc/profile, если этот файл существует.
После чтения этого файла, он смотрит следующие файлы в следующем порядке:
~/.bash_profile, ~/.bash_login и ~/.profile, читает и вызывает команды из первого,
который существует и доступен для чтения. При выходе bash читает и выполняет команды из
файла ~/.bash_logout.

Когда запускается интерактивная оболочка, но не для входа в систему, bash читает и исполняет
команды из файлов /etc/bash.bashrc и ~/.bashrc, если они существуют.
Это может быть отменено опцией -norc. Опция -rcfile file заставит Bash использовать команды
из файла file вместо /etc/bash.bashrc и ~/.bashrc.


### Дополнительно

Official:
http://www.gnu.org/software/bash/manual/bash.html

Other:
http://ruslandh.narod.ru/howto_ru/Bash-Prog-Intro/Bash-Prog-Intro.html
http://binsh.ru/tag/bash-pitfalls

Advanced Guide:
http://tldp.org/LDP/abs/html/index.html
http://wiki.bash-hackers.org/doku.php

### Форматирование

tput setab [1-7] # Set the background colour using ANSI escape
tput setaf [1-7] # Set the foreground colour using ANSI escape

Num  Colour    #define         RGB

0    black     COLOR_BLACK     0,0,0
1    red       COLOR_RED       max,0,0
2    green     COLOR_GREEN     0,max,0
3    yellow    COLOR_YELLOW    max,max,0
4    blue      COLOR_BLUE      0,0,max
5    magenta   COLOR_MAGENTA   max,0,max
6    cyan      COLOR_CYAN      0,max,max
7    white     COLOR_WHITE     max,max,max
9    default

echo "$(tput setaf 2)Test green text$(tput setaf 9)"

### Работа с файлами

Проверка:

    if [ -d '/etc/nginx' ]; then

-e exist
-f regular file
-s non-zero size file
-d directory
-h symbolic link
-z string is zero
-S socket
-p pipe

-r -w -x -g -u read/write/execute/sgid/suid
-O is you owner file
-G is you group owner

-b block device
-c character device
-t terminal device

Loop:
    
    FILES=/path/to/*
    for f in $FILES
    do
      echo "Processing $f file..."
      cat $f
    done
