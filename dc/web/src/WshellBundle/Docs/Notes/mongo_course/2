### CRUD

Create = insert()
Read = find()
Update = update()
Delete = remove()

Это базовые операции, неотделимые от языка.
Рассмотрим выполнение этих операций из mongo shell и python.

Mongo Shell имеет встроеннй интерпретатор JS (тот же, что и в брузерах - 'V8')
Т.е. мы можем свободно написать в нём:

for(i = 0; i < 3; i++) print(i + 'hello!');

Hotkeys:
Ctrl+A в начало строки
Ctrl+E в конец строки

Справка по командам доступна через help <команда>

a = 3;
b = "string";
c = ['l','i','s','t'];
d = { "a":a, "b":b, "c":c };

a++; ++a; # это работает.

С точки зрения интерпретатора, документы - это JS объекты.
Все эти объекты имеют своё собственное BSON представление, если их сохранить.
Мы можем явно использовать объекты типов:

NumberInt(1) + NumberLong(3)
new Date()
db - это тоже объект

db.people.insert( doc );

ObjectId - объект внутри каждого документа
id.str - получить в виде строки
id.getTimestamp() - получить ts добавления

db.col.find() - возвращает указатель на выборку
db.col.findOne() - сразу возвращает документ
Первым параметром передаются условия( например {'name':'vasya'}),
вторым можно указать какие параметры нужны/не нужны в выборке. (например {'_id':false})
Прим.: _id выводится всегда, если явно не указать, что его не нужно выводить


for(i=0; i<1000; i++){
	names = ['exam', 'essay', 'quiz'];
	for(j=0; j<3; j++){
		db.scores.insert( {'student':i, 'type':names[j], score: Math.round(Math.random()*100)} );}}


### Условия

Условия для цифр не очень удобные:
db.scores.find( {score: {$gt: 95}} )
Вернёт документы, с score > 95
а например $lte: <= 
(lte - less them, exclude)?

Условия для строк:  
То же самое, если выборка по алфавиту. А вот это действительно удобно -
сначала выбираем срез, потом если надо сортируем.
Поиск регистрозависим.
$exists : true/false - выборка по существованию поля
$type : 2 - выбор по типу (см. спецификацию BSON)
$regex : "e$" - всё что заканчивается на 'e'

Условия можно помещать в контейнер:
$or : [ условия ]
and используется по умолчанию

Неожиданность:
db.scores.find( {score : {$gt:50}, score : {$lt:60}} );
Выдаст все score<60 !


Интересная штука с полями, которые явлются массивами.
Условие работает со всеми элементами массива по очереди и возвращает подмассив.

Можно использовать $all для условия, если необходимы сразу несколько элементов в массиве.
favor : { $all : ['test', 'in', 'the', 'rest'] } # типа AND
или  один из указаных:
favor : { $in : ['test', 'in', 'the', 'rest'] } # типа OR

Ключи и строки следует заключать в кавычки, но это не мешает обрабатывать ключи
как адрес во вложенных структурах.


### Курсор

find() возвращает специальный объект, через который можно удобно работать с выборкой.

cur = db.people.find(); null;
Таким хитрым способом можно установить внутренний указатель курсора на 1 элемент.

printjson( cur.next() );
curhasNext();

cur.sort( {name: -1 }).limit(3).skip(2); null;

Выбор в обратном порядке 3 элементов, не считая первых 2 попавшихся.

В методах курсора также можно использовать условия:
db.scores.count({type:"essay", score : { $gt:90 }});



### Update
Первый аргумент - выборка, второй - замены.
db.peple.update( {name:"Smith"}, {name:"Bob"} );

ВНИМАНИЕ: все старые поля будут удалены!

Чтобы заменить конкретное поле, нужно использовать $set:
db.peple.update( {name:"Smith"}, {$set : {name:"Bob"}} );
И unset:
db.peple.update( {name:"Smith"}, {$unset : {name: 1}} );

$inc : {name:3} - увеличит значение на 3.

$push, $pop - положить/вытащить из стека (при вытаскивании можно указать -1 для того, чтобы
вытащить из начала)
$pull - вытащить с указанием значения.
$pushAll, $pullAll - то же, но для нескольких элементов

$addToSet - положить в массив с указанием значения.

Третьим аргументом update может принимать { upsert:true } что означает - создать новый документ,
если предпринята попытка обновить несуществующий документ.

Третьим аргументом update может принимать { multi:true } что означает - применить к нескольким.

### Remove

db.people.remove( {} )
db.drop()

Аналогично.


db.runCommand( getLastError:1 );
Получить последнюю ошибку.

Выполнить js в mongo можно так:
mongo < script.js

### А теперь в PyMongo

PyMongo, как и shell, получает данные в BSON.

findOne => find_one()

Получить 2 поля документа:
cursor = students.find({}, {'student_id':1, '_id':0})
Scores более 20 и менее 90:
query = {'type':'quiz', 'score':{'$gt':20, '$lt':90}}


### Reddit:
Добавляем в URL .json и получаем данные в json!

page = urllib2.urlopen(...)
parsed = json.loads(page.read())
for item in parsed['data']['children']:
	stories.insert(item['data'])

Если мы с помощью точечной нотации обращаемя к несущестующему узлу,
вернется просто пустая структура.



hw 2.2

ss = db.grades.find().sort( {'student_id':1} )
ssa = ss.toArray()

for( var i = 0; i<ssa.length; i++ ){ if(result[ ssa[i].student_id ] === undefined) {result[ ssa[i].student_id ] = ssa[i] } }


