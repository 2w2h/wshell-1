замыкания тоже будут понятны, потому что являются, по сути, комбинацией описанных выше двух принципов:
Анонимная функция определенная внутри любой другой функции, имеет доступ к переменным родителя.
Если родительская функция вернет дочернюю функцию в качестве результата своей работы, переменные родительской функции останутся доступны в дочерней, несмотря на то, что родительская уже отработала и ее локальные переменные должны удалиться.

Т.е. вложенная функция как бы замыкает на себя переменные из родительских скопов, не давая им уничтожиться.

Пример 1

	function outer($x) //Определение внешней функции
	{
			$y=2; //Локальная переменная внешней функции
			$inner=function ($a) use ($x, $y) //Определение внутренней функции
			{
					$b=4; //Локальная переменная внутренней функции
					/* А дальше складываются переменные внутренней и
					 * внешней функций, как будто все они локальные
					 * переменные внутренней функции
					 */
					$res=$x+$y+$a+$b;
					echo $res; //Результат 10 в нашем примере.
			};
			$inner(3); //Вызов внутренней функции
	}
	outer(1);
	
Пример 2

	$adder=function($a,$b) //У функции нет имени, но она присваивается переменной
	{
			return $a+$b; //вернуть сумму
	};

	$subber=function($a,$b) { return $a-$b; }; //То же самое, просто в одну строку

	function performAction($action, $a, $b) //Обычная функция с именем performAction
	{
			$result=$action($a,$b); //предполагается что параметр action - это функция
			return $result;
	}

	function makeDivider() //Обычная функция с именем makeDivider
	{
			return function ($a,$b) //Возвращает безымянную функцию
			{
					return $a/$b;
			};
	}

	$r1=$adder(1,2); //Вызываем безымянную функцию через переменную. r1=1+2;
	$r2=performAction($subber,6,4); //Передаем функцию в другую функцию. r2=6-4;
	$r3=performAction(function($a,$b) {return $a*$b;} ,5,6); //То же самое прямо на лету. r3=5*6;
	$divider=makeDivider(); //Вызываем функцию, которая возвращает функцию, сохраняем результат
	$r4=$divider(16,4); //Вызываем функцию возвращенную функцией через переменную: r4=16/4;
	//А такие вещи как в r5 в PHP вообще не прокатывают.
	//$r5=makeDivider()(32,16);//То же самое, но без промежуточной переменной: r5=32/16;
	$r5='php fail';
	echo "$r1,$r2,$r3,$r4,$r5"; //3,2,30,4,php fail
	
Подводя итоги: Анонимные функции и замыкания — очень мощный инструмент.
И как любой мощный инструмент, требуют очень аккуратного применения.
Они могут существенно упростить код программы, сделать его красивее и повысить его читаемость,
а могут ровно наоборот — сделать его абсолютно нечитаемым. Замыкания очень часто применяются в
качестве функций обратного вызова при программировании графических интерфейсов.
Очень удобно вешать их в качестве обработчиков нажатий на разные кнопочки.
Но на PHP практически никто не делает программы с GUI, и на это есть некоторые
причины — PHP все же язык веб-сценариев, а не десктоп приложений.
Поэтому анонимные функции хороши в preg_replace_callback, array_filter и тому подобных функциях,
а замыкания следует оставить для Javascript, Python и других языков, где они реализованы
действительно хорошо и где реально нужны для использования в GUI.