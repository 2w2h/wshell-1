### Общая информация

Регулярное выражение имеет вид:

	#выражение#модификатор

Вместо # может быть любой другой символ, кроме букв/цифр, обратного слэша '\' и нулевого байта.

В общем случае, символ в шаблоне соответствует символу в проверяемой строке. Например шаблон **#The quick brown fox#**
будет соответствовать только строке **The quick brown fox**.


### Метасимволы

Служебные символы (так называемые метасимволы):

- \ несколько значений:
	- экранирование, если стоит перед метасимволом
	- для использования в шаблоне непечатных/Unicode/hex/oct-символов
	- ссылка на подмаску
	- указание типа символов, см. [ниже](/doc/?book=checking#типы-символов)
	- формальное утверждение о положении символа в строке, см. [ниже](/doc/?book=checking#положение-символа)
- ^ начало данных (или строки в многострочном режиме)
- $ конец данных (или строки в многострочном режиме)
- . один любой символ, кроме перевода строки
- [] **символьный класс**
	- ^ отрицание
	- \- символьный интервал
- | альтернативный выбор (ИЛИ)
- () **подмаска**
- ? расширение смысла метасимвола ИЛИ квантификатор <=1 ИЛИ преобразование в "ленивый" квантификатор
- \* квантификатор >=0
- \+ квантификатор >=1
- {} **количественный квантификатор**. {min, max}. По сути, заменяет любую нотацию квантификаторов.


### Просмотр вперед или назад

Используется, когда имеет значение 'контекст' шаблона (что до/после него)
(?шаблон)

- ?#N - Это оператор "просмотра назад". N - число символов для просмотра.
- ?~N - Отрицание просмотра назад.
- ?= - Просмотр вперед.
- ?! - Отрицание просмотра вперед.


### Квантификаторы

Квантификаторы определяют количество повторений сигнатуры перед ними.
По умолчанию, все квантификаторы являются жадными.
ИНВЕРТИРОВАТЬ жадность можно, добавив в сразу после него знак ?.
Например, шаблон /\*.*?\*/ корректно находит все комментарии языка Си. 


### Якоря

Якорями называются символы начала и конца строки. Не работают в многострочном режиме (точнее, привязываются
не к началу данных, а к началу строки). Альтернатива, независимая от режима - \A, \Z, \z.

### Подмаски

Подмаска имеет следующий смысл:

- Локализация набора альтернатив. Например cat(egory|alog) соответствует словам category и catalog.
- Захват подстрок. Т.е. соответствия записываются в индексный массив.
Например, если строка "the red king" сопоставляется с шаблоном the ((red|white) (king|queen)),
будут захвачены подстроки "red king", "red" и "king", с номерами 1, 2 и 3 соответственно.

Чтобы отменить захват, нужно начинать подмаску с ?: или ?модификатор:  
Например, если строка "the white queen" сопоставляется с шаблоном the ((?:red|white) (king|queen)),
будут захвачены подстроки "white queen" и "queen", и они будут пронумерованы 1 и 2 соответственно.

Синтаксис  (?<name>pattern) или (?'name'pattern) может быть использован для именования подмасок.

Иногда бывает необходимо иметь несколько совпадений, исключающих друг друга.
Обычно, каждое такое совпадение получает свой собственный номер,
даже если шаблон позволяет совпасть только одному из них.
Синтаксис (?| позволяет обойти это поведение и убрать дублирующиеся номера.
Рассмотрим следующее регулярное выражение, сопоставленное со строкой Sunday:

(?:(Sat)ur|(Sun))day
Здесь Sun сохраняется в ссылке 2, тогда как ссылка 1 пуста. Если же совпадет Sat,
то она будет помещена в ссылку 1, а ссылка 2 вообще не будет существовать. Использование (?| в шаблоне решает эту проблему:

(?|(Sat)ur|(Sun))day
В этом шаблоне обе подмаски Sun и Sat будут сохранены под номером 1.

### Модификаторы

- i - не учитывать регистр
- m - расширенный режим привязки к границам строк
- s - совпадение точки со всеми символами
- x - режим свободного форматирования
- u - режим Unicode
- X - использование дополнительных возможностей PCRE

i - не различать строчные и заглавные буквы.
m - считать строку многострочной.
s - однострочная строка.
x - расширенный синтаксис ( использование пробелов и комментариев)
e - после выполнения стандартных подстановок в заменяемой строке интерпретирует ее как PHP-код и использует результат для замены искомой строки. 
A - соответствие шаблону будет достигаться только в том случае, если он соответствует началу строки, в которой производится поиск.
D - метасимвол $ в шаблоне соответствует только окончанию обрабатываемых данных. Без этого модификатора метасимвол $ соответствует также позиции перед последним символом, в случае, если им является перевод строки (но не распространяется на любые другие переводы строк). Данный модификатор игнорируется, если используется модификатор m. В языке Perl аналогичный модификатор отсутствует.
S - если данный модификатор используется, проводится дополнительный анализ шаблона. В настоящем это имеет смысл только для фиксированных шаблонов, не содержащих переменных ссылок.
U - модификатор инвертирует жадность квантификаторов, таким образом они по умолчанию не жадные. Но становятся жадными, если за ними следует символ '?'. Такая возможность не совместима с Perl. Модификатор U также может использоваться внутри шаблона, при помощи '?U' записи.
X - включает дополнительную функциональность PCRE, которая не совместима с Perl: любой обратный слеш в шаблоне, за которым следует символ, не имеющий специального значения, приводят к ошибке. Это обусловлено тем, что подобные комбинации зарезервированы для дальнейшего развития. По умолчанию же, как и в Perl, слеш со следующим за ним символом без специального значения трактуется как as опечатка. На сегодняшний день это все возможности, которые управляются данным модификатором
u - включает дополнительную функциональность PCRE, которая не совместима с Perl: шаблоны обрабатываются как UTF8 строки. Модификатор u доступен в PHP 4.1.0 и выше для Unix-платформ, и в PHP 4.2.3 и выше для Windows платформ.

Также можно устанавливать встроенные модификаторы с помощью конструкции (?модификаторы).  
Например, /ab(?i)c/ совпадет только с "abc" и "abC".

### Символьные классы

Для построения символьных диапазонов используется ASCII представление символов.

Также можно использовать следующие символьные классы:

* alnum - буквы и цифры
* alpha - буквы
* ascii - символы с кодами 0 - 127
* blank - только пробел или символ табуляции
* cntrl - управляющие символы
* digit - десятичные цифры (то же самое, что и \d)
* graph - печатные символы, исключая пробел
* lower - строчные буквы
* print - печатные символы, включая пробел
* punct - печатные символы, исключая буквы и цифры
* space - пробельные символы(почти то же самое, что и \s)
* upper - прописные буквы
* word - символы "слова" (то же самое, что и \w)
* xdigit - шестнадцатеричные цифры

### Типы символов

Символ, образующий "слово" - это произвольная цифра, буква или символ подчеркивания. Однако в разных локалях  буквой считаюся разные символы.

- \d любая десятичная цифра
- \D любой символ, кроме десятичной цифры
- \h любой горизонтальный пробельный символ
- \H любой символ, не являющийся горизонтальным пробельным символом
- \s любой пробельный символ
- \S любой непробельный символ
- \v любой вертикальный пробельный символ
- \V любой символ, не являющийся вертикальным пробельным символом
- \w Любой символ, образующий "слово"
- \W Любой символ, не образующий "слово"

- \xNN - NN - шестнадцатеричный код ASCII-символа
- \033 - восьмеричная запись символа
- \x1A - шестнадцатеричная

**Замечание**: Конец строки в Windows это CR+LF (\r\n), в Linux LF (\n), в OS X CR (\r)  
\R в preg_* совпадает со всеми этими вариантами.

### Положение символа

Описанные тут последовательности не могут встречаться в символьных классах (исключая комбинацию "\b", которая внутри класса означает символ возврата 'backspace').

- \b граница слова
- \B не является границей слова
- \A начало данных (независимо от многострочного режима)
- \Z конец данных либо позиция перед последним переводом строки (независимо от многострочного режима)
- \z конец данных (независимо от многострочного режима)
- \G первая совпадающая позиция в строке


### Примеры

Всё, что после //, но не после http://

	@\s*(?<!:)//.*?$@m