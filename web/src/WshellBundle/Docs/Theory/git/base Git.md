### Основные команды

![gitflow](media/git/basic/basic-usage.png)

Следующие четыре команды предназначены для копирования файлов между рабочей директорией, сценой (так же известной как «индекс») и историей (представленной в форме коммитов).

git add файлы копирует файлы (в их текущем состоянии) на сцену.
git commit сохраняет снимок сцены в виде коммита.
git reset -- файлы восстанавливает файлы на сцене, а именно копирует файлы из последнего коммита на сцену.
Используйте эту команду для отмены изменений, внесенных командой git add файлы. Вы также можете выполнить git reset чтобы восстановить все файлы на сцене.
git checkout -- файлы копирует файлы со сцены в рабочую директорию. 
Эту команду удобно использовать чтобы сбросить нежелательные изменения в рабочей директории.
Вы можете использовать git reset -p, git checkout -p, и git add -p вместо (или вместе с) именами файлов,
чтобы в интерактивном режиме выбирать, какие именно изменения будут скопированы.

Также можно перепрыгнуть через сцену и сразу же получить файлы из истории прямо в рабочую директорию; или сделать коммит, минуя сцену.


git commit -a аналогичен запуску двух команд: git add для всех файлов, которые существовали в предыдущем коммите, и git commit.
git commit файлы создает новый коммит, в основе которого лежат уже существующие файлы, добавляя изменения только для указанных файлов. Одновременно, указанные файлы будут скопированы на сцену.
git checkout HEAD -- файлы копирует файлы из текущего коммита и на сцену, и в рабочую директорию.
Соглашения

Иллюстрации в этой справке выдержаны в единой цветовой схеме.


Коммиты раскрашены зеленым цветом и подписаны 5-ти буквенными идентификаторами. Каждый коммит указывает на своего родителя зеленой стрелочкой. Ветки раскрашены оранжевым цветом; ветки указывают на коммиты. Специальная ссылка HEAD указывает на текущую ветку. На иллюстрации вы можете увидеть последние пять коммитов. Самый последний коммит имеет хеш ed489. master (текущая ветка) указывает на этот коммит, maint (другая ветка) указывает на предка master-ового коммита.

Подробно о командах

Diff

Есть много способов посмотреть изменения между коммитами. Ниже вы увидите несколько простых примеров. К каждой из этих команд можно добавить имена файлов в качестве дополнительного аргумента. Так мы выведем информацию об изменениях только для перечисленных файлов.


Commit

Когда вы делаете коммит, git создает новый объект коммита, используя файлы со сцены, а текущей коммит становится родителем для нового. После этого указатель текущей ветки перемещается на новый коммит. Вы это видите на картинке, где master — это текущая ветка. До совершения коммита master указывал на коммит ed489. После добавления нового коммита f0cec, родителем которого стал ed489, указатель ветки master был перемещен на новый коммит.


То же самое происходит, если одна ветка является предком другой ветки. Ниже показан пример нового коммита 1800b в ветке maint, которая является предком ветки master. После этого ветка maint уже больше не является предком ветки master. И в случае необходимости объединения работы, проделанной в этих разделенных ветках, вам следует воспользоваться командой merge (что более предпочтительно) или rebase.


Если вы сделали ошибку в последнем коммите, её легко исправить с помощью команды git commit --amend. Эта команда создает новый коммит, родителем которого будет родитель ошибочного коммита. Старый ошибочный коммит будет отброшен, конечно же если только на него не будет ещё каких-либо других ссылок, что маловероятно.


Четвертый случай коммита из состояния «detached HEAD» будет рассмотрен далее.

Checkout

Команда checkout используется для копирования файлов из истории или сцены в рабочую директорию. Также она может использоваться для переключения между ветками.

Когда вы указываете имя файла (и/или ключ -p), git копирует эти файлы из указанного коммита на сцену и в рабочую директорию. Например, git checkout HEAD~ foo.c копирует файл foo.c из коммита HEAD~ (предка текущего коммита) в рабочу директорию и на сцену. Если имя коммита не указано, то файл будет скопирован со сцены в рабочую директорию. Обратите внимание на то что при выполнении команды checkout позиция указателя текущей ветки (HEAD) остаётся прежней, указатель никуда не перемещается.


В том случае если мы не указываем имя файла, но указываем имя (локальной) ветки, то указатель HEAD будет перемещен на эту ветку (мы переключимся на эту ветку). При этом сцена и рабочая директория будут приведены в соответствие с этим коммитом. Любой файл, который присутствует в новом коммите (a47c3 ниже) будет скопирован из истории; любой файл, который был в старом коммите (ed489), но отсутствует в новом, будет удален; любой файл, который не записан ни в одном коммите, будет проигнорирован.


В том случае, если мы не указываем имя файла, и не указываем имя (локальной) ветки, а указываем тег, дистанционную (remote) ветку, SHA-1 хеш коммита или что-то вроде master~3, то мы получаем безымянную ветку, называемую «Detached HEAD» (оторванная голова). Это очень полезная штука для если нам надо осмотреться в истории коммитов. К примеру, вам захочется скомпилировать git версии 1.6.6.1. Вы можете набрать git checkout v1.6.6.1 (это тег, не ветка), скомпилировать, установить, а затем вернуться в другую ветку, скажем git checkout master. Тем не менее, коммиты из состояния «Detached HEAD» происходят по своим особым важным правилам, и мы рассмотрим их ниже.


Коммит из состояния «Detached HEAD»

Когда мы находимся в состоянии оторванной головы (Detached HEAD), коммит совершается по тем же правилам, что и обычно за исключением одной маленькой особенности: ни один указатель ветки не будет изменен или добавлен к новому коммиту. Вы можете представить эту ситуацию как работу с анонимной веткой.


Если после такого коммита вы переключитесь в ветку master, то коммит 2eecb, совершенный из состояния «Detached HEAD» потеряется и попросту будет уничтожен очередной сборкой мусора только потому нет ни одного объекта, который бы на него ссылался: ни ветки, ни тега.


В том случае, если вы хотите сохранить этот коммит на будущее, вы можете создать на основе его новую ветку командой git checkout -b new.


Reset

Команда reset перемещает указатель текущей ветки в другую позицию, и дополнительно может обновить сцену и рабочую директорию. Эту команду можно также использовать для того чтобы скопировать файл из истории на сцену, не задевая рабочую директорию.

Если коммит указан без имен файлов, указатель ветки будет перемещен на этот коммит, а затем сцена приведется в соответствие с этим коммитом. Если мы используем ключ --soft, то сцена не будет изменена. Если мы используем ключ --hard, то будет обновлена и сцена, и рабочая директория.


Если имя коммита не будет указано, по умолчанию оно будет HEAD. В этом случае указатель ветки не будет перемещен, но сцена (а также и рабочая директория, если был использован ключ --hard) будут приведены к состоянию последнего коммита.


Если в команде указано имя файла (и/или ключ -p), то команда работает также как checkout с именем файла, за исключением того, что только сцена (но не рабочая директория) будет изменена. Если вы подставите имя коммита на место двойной черты, вы сможете получить состояние файла из этого коммита, тогда как в случае с двойной чертой вы получите состояние файла из коммита, на который указывает HEAD.


Merge

Команда merge (слияние) создает новый коммит на основе текущего коммита, применяя изменения других коммитов. Перед слиянием сцена должна быть приведена в соответствие с текущим коммитом. Самый простой случай слияния — это когда другой коммит является предком текущего коммита: в этом случае ничего не происходит. Другой простой случай слияния — когда текущий коммит является предком другого коммита: в этом случае происходит быстрая перемотка (fast-forward). Ссылка текущей ветки будет просто перемещена на новый коммит, а сцена и рабочая директория будут приведены в соответствие с новым коммитом.


Во всех других случаях выполняется «настоящее» слияние. Вы можете изменить стратегию слияния, но по умолчанию будет выполнено «рекурсивное» слияние, для которого будет взят текущий коммит (ed489 ниже на схеме), другой коммит (33104) и их общий предок (b325c); и для этих трех коммитов будет выполнено трехстороннее слияние. Результат этого слияние будет записан в рабочую директорию и на сцену, и будет добавлен результирующий коммит со вторым родителем (33104).


Cherry Pick

Команда cherry-pick («вишенка в тортике») создает новый коммит на основе только одного сладкого «коммита-вишенки», применив все его изменения и сообщение.


Rebase

Перебазирование (rebase) — это альтернатива слиянию для задач объединения нескольких веток. Если слияние создает новый коммит с двумя родителями, оставляя нелинейную историю, то перебазирование применяет все коммиты один за одним из одной ветки в другую, оставляя за собой линейную историю коммитов. По сути это автоматическое выполнение нескольких команд cherry-pick подряд.


На схеме выше вы видите как команда берет все коммиты, которые есть в ветке topic, но отсутствуют в ветке master (коммиты 169a6 and 2c33a), и воспроизводит их в ветке master. Затем указатель ветки перемещается на новое место. Следует заметить, что старые коммиты будут уничтожены сборщиком мусора, если на них уже ничего не будет ссылаться.

Используйте ключ --onto чтобы ограничить глубину захвата объединяемой ветки. На следующей схеме вы можете увидеть как в ветку master приходят лишь последние коммиты из текущей ветки, а именно коммиты после (но не включая) 169a6, т. е. 2c33a.


Есть также интерактивный режим перебазирования git rebase --interactive, с помощью которого вы сможете сделать вещи похитрее простого линейного применения коммитов, а именно сбрасывание (dropping), изменение порядка (reordering), правка (modifying) и выдавливание (squashing) коммитов. Нет наглядной схемы, чтобы показать эти возможности; за описанием лучше обратиться к справке по git-rebase(1).

Технические заметки

Содержание файлов не хранится в индексе (.git/index) или в объектах коммитов. Правильнее было бы сказать, что каждый файл хранится в базе данных объектов (.git/objects) в двоичном представлении; найти этот файл можно по его SHA-1 хешу. В файле индекса записаны имена файлов, их хеши и дополнительная информация. В информации о коммитах вы встретите тип данных дерево, для идентификации которого также используется SHA-1 хеш. Деревья описывают директории в рабочей директории, а также содержат информацию о других деревьях и файлах в принадлежащей к обозначенному дереву. Каждый коммит хранит идентификатор своего верхнего дерева, которое содержит все файлы и другие деревья, измененные в этом коммите.

Если вы делаете коммит из состояния «оторванной головы» (detached HEAD), то на этот коммит будет ссылаться ссылка истории HEAD. Но рано или поздно время хранения этой ссылки истечет, и этот коммит будет уничтожен сборщиком мусора точно также, как это делается при выполнении команд git commit --amend и git rebase.