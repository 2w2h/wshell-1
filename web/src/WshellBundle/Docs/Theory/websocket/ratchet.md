Ratchet - это php библиотека для работы с web-сокетами, основанная на более
низкоуровневой библиотеке react, предназначенной в целом для асинхронной работы с клиентами.
(Которая, если копнуть глубже, юзает ext-zmq, модуль для php, основанный на C++ библиотеке
ZeroMQ)

В классическом web'е каждый HTTP запрос - это отдельная TCP сессия. В web сокетах обмен данными
происходит внутри одной TCP сессии, без лишних накладных расходов.

Тут как минимум, два огромных плюса:

* Полноценное событийно-ориентированное программирование: cобытия создает
не только пользователь, но и сервер.
* Cервер знает о всех установленных в данный момент соединениях и может
эффективно "маршрутизировать" данные между клиентами.

### Архитектура: Компоненты и Соединения

Ядро Ratchet состоит из Компонентов, имеющих общий интерфейс (ComponentInterface).
Компонент(по сути - сервер) инстанцируется один раз при запуске
соответствующего скрипта и как бы "отделяется" от него. Теперь это независимый обработчик
событий, приходящих от клиентов, связанных с этим обработчиком.

События клиента для Компонентов Socket Transport, HTTP handler, WebSocket Handler, 
Session Provider:
open, close, data, error.
Для WAMP(WS messaging protocol): open, close, publish, subscribe, unsubscribe, call, prefix, error.

Также есть Соединения - объекты представляющие собой сами соединения.
Каждое соединение содержит в себе некоторую информацию о клиенте, поэтому оно может
быть удобным образом связано с механизмом сессий.
Каждое соединение имеет как минимум 2 метода - send() и close(), которые соответственно служат
для отправки сообщения на клиент или закрытия соединения.

Несмотря на то, что каждое соединение независимо от других, может быть удобно
иметь общий контейнер для всех соединений. Например:

	<?php
	use Ratchet\Resource\ConnectionInterface;

	class MyApp {
	    protected $connections;

	    public function __construct() {
		$this->connections = new \SplObjectStorage;
	    }

	    public function onOpen(ConnectionInterface $conn) {
		$this->connections->attach($conn);
	    }

	    public function onClose(ConnectionInterface $conn) {
		$this->connections->detach($conn);
	    }
	}
