### Структура данных

Rich Documents
Предварительные Join's/Embed данные
No mange joins
No declared schema
и др

Самое главное при проектировании структуры данных -
соответствие паттернам доступа данных твоего приложения.

отстуствие JOIN ов в mongo означает только то, их придется делать вручную
в своем приложении.
Впрочем, ничего плохого в дополнительном поле документа нет. Оно может быть скаляром
(для one-to-many) или массивом(для many-to-many). Эта фича называется multikey indexes

Для создания индексов подходит команда типа db.students.ensureIndex( {'teachers':1} )
Для отладки запроса можно заюзать db.students.ensureIndex( {'teachers':1} ).explain()

По сути, есть выбор:
При большом количесиве элементов связные документы нужно хранить в разных коллекциях,
иначе - лучше в одной.

DBRef - коллекция коллекции и _id документов, предназначенная для создания
ссылок между коллекциями.
Т.е. хотя у mongo и нет внешего ключа, данные нужно хранить
в консистентном состоянии (согласованность данных друг с другом, целостность данных,
а также внутренняя непротиворечивость.)

Вспомним нормальные формы:
1 - в одной ячейке не может быть нескольких записей
2 - в каждой таблице лишь 1 первичный ключ
3 - каждый неключевой атрибут может быть зависим только от ключа

Одна из основных целей нормализации - избегать предвзятости к модели доступа - в mongo не работает.
Mongo денормализирован.


### Trees

Документы можно логически объединять в деревья (отношения parent<->child)
Для этого лучше использовать дополнительное поле, не связанное с _id.

Например, parent_id - непосредственно предыдущий узел и массив ancestors( все предки )


### GRIDFS

Mongo умееть хранить бинарные данные.
Для этого заюзаем питоновскую библиотеку gridfs

	grid = gridfs.GridFS(db, "text")
	fin = open(file_used, "r")

	_id = grid.put(fin)
	fin.close()
	print "id of file is", _id

	file_meta.insert( { "grid_id": _id, "filename": file_used})

Файлы хранятся чанками
