Имена должны передавать намерения программиста.
Имя переменной, функции или класса должно отвечать на все главные вопросы.
Оно должно сообщить, почему эта переменная (и т. д.) существует, что она делает
и как используется.

int elapsedTimelnDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgelnDays:

source и destination.

if (cell[STATUS_VALUE] == FLAGGED)
->
flaggedCells.add(cell)


Имена переменных должны быть наглядными и хорошо различаемыми.

Не следует использовать имя контейнера в названии переменной(напр. List)

В имени не должно быть избыточности (Account лучше чем AccountData)

genymdhms генья-мадда-химс

Длина имени должна соответствовать размеру его области видимости.
Примеры допустимых коротких: i,j(индексы) e(ошибка)

В имени должен быть закодирован внутренний смысл(own, shared)???
Так то лишние условности для изучения.
Точно не нужны описания типа, префиксы

стр 49 Именв классов - плохой совет


Имена классов - существительные, методов - глаголы

При неочевидных параметрах конструктора,
конструктор желательно использовать через статический метод-фабрику.
т.е.  private __construct() и
static function FromRealNumber()
{
	return new Complex();
}
иогда создание будет Point = Complex.FromRealNumber(x);

fetch, retrieve и get - одно и тоже! нужно придерживаться одного имени
для удобного запоминания.
С другой стороны похожие методы (insert для вставки,append для конкатенации ,add для сложения)
могут иметь разную догику, следовательно и названия должны быть разными.

Не забывайте: ваш код будут читать программисты. А раз так, не стесняйтесь 
использовать термины из области информатики, названия алгоритмов и 
паттернов, математические термины и т. д.
Также удачным решением является использование терминов из предметной области.




### Функции

Функция должна быть очень компактной. Рекомендуемая длина: 20 строк.
Но если читаемость хорошая может быть и длиннее.

TO-абзац: короткое описание задачи, выполняемой фунцией. Задача
должна быть на одном уровне абстракции.

У функции не должно быть более 3 аргументов. помимо того, что их сложно
запомнить, их также сложно тестировать.

Унарные(1 аргумент). Типичные:
void fileExists("MyFile") - проверка
string fileOpen("MyFile") - обработка
void eventOpen("MyFile") - событие

Передача флагов как аргументов - уродлива, так как предполагает
несколько разных поведений функции.

Для уменшения количества аргументов можно использовать два подхода:

    1) Разделить 1 фунуцию на 2 последовательных.
    2) Объединить аргументы в единую сущность:
	Circle makeCircle(double х, double у, double radius);
	=>
	Circle makeCircle(Point center, double radius);

Фунция не должна изменять аргумент! Это неочевидное поведение.

try/catch следует выделять в отдельные функции.

Опытные программисты рассматривают систему как историю, которую они
должны рассказать, а не как программу, которую нужно написать.


### Комментарии

Комментарий, нужен только тогда когда код нельзя сделать достаточно очевидным.
Закомментированный код - это очень плохо.

Комментарии для документации должны относиться только к внешнему API.


### Форматировние

Логические блоки должны быть разделены пустой строкой.
Объявление переменной должно быть расположено рядом с её использованием.
(Исключение - свойства классов. Они должны быть в начале.)

Длина строки - не более 120 символов.

Пробелы должны быть в присваивании, между перечислениями,
в формулах вокруг низкоприоритетных операций.


### Объекты

Объекты скрывают свои данные за абстракциями и предоставляют функции,
работающие с этими данными. Структуры данных раскрывают свои данные и не
имеют осмысленных функций.

закон Деметры: модуль не должен знать внутреннее устройство тех объектов,
с которыми он работает.
Т.е. в библиотеке нельзя делать так X->fOne()->fTwo();

Искусственная структура данных - класс с public свойствами и без методов.
(DTO, Data Transfer Object)
Структуры DTO чрезвычайно полезны, 
особенно при работе с базами данных, разборе сообщений из сокетов и т. д.
Варианты: Beans (private свойства + геттеры/сеттеры) и
Active Record- то же, но с навигационными элементами (find, save).



### Сторонний код

Для изучения стороннего API будет не лишним написать учебные тесты под него.
(Если, конечно, он не поставляется с ними.)


### Модульные тесты

Тесты нужно писать паралельно и соизмеримо разработке.
Тесты должны быть максимально удобочитаемы и выразительны.
Один тест == одна проверка.


### Классы

Порядок: свойства(статика, открытые, закрытые), методы(статика, открытые, закрытые).
Класс должен быть компактным. Компактность определяется размером API класса.
Класс должен соответствовать одной задаче.
Класс нужно писать так, чтобы в дальнейшем его не нужно было менять из-за
изменения в другом коде.


### Архитектура

4 правила простой архитектуры:

    * Прохождение всех тестов
    * Нет повторяющегося кода
    * Выражение намерений программиста
    * Минимальное количество классов и методов


### Многопоточность
### Последовательное очищение

