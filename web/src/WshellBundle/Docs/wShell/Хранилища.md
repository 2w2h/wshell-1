### Хранение данных

Работа многих юнитов подразумевает хранение промежуточных данных, также может быть удобно
перенаправить вывод в место, где данные могут быть сохранены и в дальнейшем опять использованы.

Именно для этого существует целый набор служебных юнитов класса Storage, которые позволяют
не только сохранять данные, но и эффективно их обрабатывать. Для хранения данных используется
сетевое журналируемое хранилище Redis.

Исходя из этого, важно понимать что хранилища wShell не являются чем-то статичным, постоянным
и медлительным. Предполагается что Redis будет хранить **текстовые данные**, в том числе и
структурированные, что плохо подходит для, скажем, видео и аудио. Если вдруг, ВНЕЗАПНО,
нужно будет хранить что-то очень большое, будут использоваться или сторонние сервисы,
или же пользователь должен будет сам указать способ взаимодействия с его собственными хранилищами (FTP,WebDAV).


### Базы данных и контекст

Всего юниты используют 5 баз данных типа "ключ-значение". Это означает, что любые сохранённые данные
имеют своего рода адрес из комбинации номера базы и ключа, по которому происходит доступ.

Отчего зависит выбор базы данных и как формируется ключ?

Введем понятие **контекст** - это условия от которых зависит место хранения, а именно:

1. Авторизованность пользователя. Данные могут сохранятся независимо от того, залогинен пользователь или нет,
просто храниться эти данные будут в разных местах. Это сделано исключительно для удобства -
пользователю не обязательно регестрироваться, "автору" юнита не должен ломать голову над тем, где и как хранить данные.
2. Режим хранения. Этот параметр задается в коде юнита и зависит от назначения юнита.
(см. далее.)

Для наглядности - таблица, по которой всё должно стать понятно =)
![Storages](/img/doc/storages.png "Storages")

Режимы:

* ENV(environment) - режим окружения. Привязка данных к конкретному пользователю конкретного юнита.
* PUB(public) - общее хранилище для пользователей одного юнита.
* PER(personal) - данные привязаны к пользователю, но могут быть использованы всеми юнитами. Имеется ввиду
явное использование, т.е. только тогда, когда пользователь сам указал юниту на свои данные.
* ANO(anonymity) - режим анонимного хранения. В отличие от всех остальных режимов,
ключ генерится случайно и явно выдается пользователю.
**UPD.: Здесь имеется ввиду контекстная часть ключа. См. далее.**

Теперь пройдемся по базам:

* Первая целиком и полностью соответствует режиму ENV. Тут всё ясно.
* Вторая и четвертая никак не различают пользователей, и отличаются только тем,
что вторая **принадлежит юнитам** (юнит читает оттуда, когда захочет),
а четвертая - пользователям. Интересной побочной особенностью анонимного хранения является то,
что оно может использоваться как "средство обмена", так как ключ можно передавать третьему лицу.
* Пятая база является временным аналогом 1ой и 3ей. Почему разные по назначению хранилища объединены в одно?
Всё очень просто - для гостей в качестве составляющей ключа используется временный идентификатор.
Заканчивается сессия - идентификатор изчезает и смысл в хранении также изчезает - без идентификатора
эти данные уже невозможно будет излечь, получается своего рода мусорка с временными данными.
"Просроченные" ключи в этой базе переодически удаляются.


### Storages в юнитах (пример для PHP)

В большинстве случаев юнит работает с одним контекстом, поэтому класс `Unit` имеет встроенный
интерфейс работы с хранилищами:

	// $data - ассоциативный массив `[key] => value`, value - переменная любого типа.
	// режим по умолчанию - 'env'
	$this->save($data, $mode = 'env');
	$this->load($keys, $mode = 'env');

Этот интерфейс позволяет сохранять и загружать целые наборы данных. Используйте его в случае,
если нет нужды использовать хранимые данные в другом контексте.


### `class Storage`

Помимо простого метода есть сложный. Он отличается лучшей производительностью и гибкостью.
Дело в том, что Redis умеет намного больше, чем просто save&load.
На этих [32 страницах](https://github.com/kondratovich/the-little-redis-book/downloads) описано всё самое важное +
[документацию](http://redis.io/documentation) никто не отменял.

Аналог примера сверху:

	// инициализация хранилища.
	$stor = new Storage($mode, $unitName, $userId);
	//Сохранение. В анонимном режиме ключ не указывается, а возвращается методом save.
	$stor->save($value, $key);
	// загрузка данных
	$value = $stor->load($key);

	// Кастомный запрос к Redis, см. http://redis.io/commands
	// ВАЖНО: при обращении к Redis напрямую придётся вручную "собирать" любые
	// ключи, содержащиеся в $args, в полном соответствии с таблицей выше.
	$stor->execute($command, $args = array());

Отличие в том, что контекст указывается явно и данные должны сохраняться поэлементно.

ВАЖНО: в приведённых примерах ключи - _это не те ключи_, которые реально используются при хранении, а только
их кастомная часть. Как уже было сказано, о ключе контекста должны заботиться сами классы семейства `Storage`.  
![Key](/img/doc/storKey.png "storKey")

`stringStorage, hashStorage, listStorage, setStorage, sortedSetStorage` - классы, специфичные для каждого типа данных Redis.

Каждый из перечисленных классов расширяет возможности хранения в соответствии с одним из типов данных,
определенных в Redis. Для наглядности, к каждому из этих классов написан служебный юнит с таким же именем.

* string - тексты, цифры, небольшие битовые последовательности. Много интересных применений, например:
битовые маски, счётчики, хранение сериализованных данных.
* hash - тоже самое, только в виде ассоциативных массивов. Удобно использовать для хранения объектов,
в том числе JSON.
* list - индексированный массив. Используются для хранения ссылок на другие ключи, последовательностей ходов в игре,
путей перемещения, для очередей.
* set - аналог математических множеств, элеметы уникальны и ненумерованы (Список участников, теги и т.д.)
* sorted set - для рейтингов, весовых коэффициентов, отслеживания событий.
